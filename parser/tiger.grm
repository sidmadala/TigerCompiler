structure A = Absyn

%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN | UMINUS
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE 

%nonterm program of A.exp
       | exp of A.exp
       | exp_seq of (A.exp * A.pos) list
       | opexp of A.exp
       | lvalue of A.var
       | lvalue_not_id of A.var
       | fundec of A.fundec
       | funlist of A.fundec list
       | funExp of A.exp
       | funArgs of A.exp list
       | dec of A.dec
       | declist of A.dec list
       | vardec of A.dec
       | ty of A.ty
       | tydec of {name: A.symbol, ty: A.ty, pos: A.pos}
       | tyfields of A.field list
       | tylist of {name: A.symbol, ty: A.ty, pos: A.pos} list
       | arrayRecordBuilder of A.exp
       | record_param of (A.symbol * A.exp * A.pos) list

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

(* TODO: Fix the precedence rules and make sure the Michelle isn't mean to me anymore *)
%nonassoc ASSIGN
%right DO
%right OF
%right THEN
%right ELSE
%left OR
%left AND
%nonassoc EQ NEQ LT GT LE GE
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS

%%

(* Programs are just expressions (default) *)
program : exp				                                   (exp)

(* general exp *)
exp:     NIL		                                                 (A.NilExp)
       | STRING                                                       (A.StringExp(exp, expleft))
       (* conditional *)
       | IF exp THEN exp ELSE exp                                     (A.IfExp {test = exp1, then' = exp2, else' = SOME exp3, pos: exp1left}) 
       | IF exp THEN exp                                              (A.IfExp {test = exp1, then' = exp2, else' = NONE exp3, pos: exp1left})
       (* math *)
       | opexp                                                        (opexp) 
       (* loops *)
       | WHILE exp DO exp                                             (A.WhileExp {test = exp1, body = exp2, pos = exp1left})
       | FOR ID ASSIGN exp TO exp DO exp                              (A.ForExp {var = A.symbol(ID), escape = ref true, lo = exp1, hi = exp2, body = exp3, pos: FORleft})
       | BREAK                                                        (A.BreakExp(BREAKleft))
       (* let decs list with all types of declarations + mutually recursive list stuff *)
       | LET declist IN exp_seq END                                   (A.LetExp({decs = declist, body = A.SeqExp(exp_seq), pos = LETleft}))
       | LET declist IN END                                           (A.LetExp({decs = declist, body = A.SeqExp([]), pos = LETleft}))
       (* misc parentheses *)
       | LPAREN exp RPAREN			                            (exp)
       | LPAREN RPAREN                                                (A.SeqExp([]))
       | LPAREN exp SEMICOLON exp_seq RPAREN                          (A.SeqExp((exp, expleft) :: exp_seq))
       (* lvalue exp and assignment *)
       | lvalue_not_id                                                (A.VarExp(lvalue_not_id))
       | lvalue ASSIGN exp                                            (A.AssignExp{var = lvalue, exp = exp, pos = lvalueleft})
       (* arrays and records *)
       | arrayRecordBuilder                                           (arrayRecordBuilder)
       (* functions *)
       | funExp                                                      (funExp)

(* Arithmetic *)
opexp : MINUS exp %prec UMINUS                                        (A.OpExp {left = A.IntExp(0), oper = A.MinusOp, right = exp2, pos = exp1left})
       | exp PLUS exp                                                 (A.OpExp {left = exp1, oper = A.PlusOp, right = exp2, pos = exp1left})             
       | exp MINUS exp                                                (A.OpExp {left = exp1, oper = A.MinusOp, right = exp2, pos = exp1left})            
       | exp TIMES exp                                                (A.OpExp {left = exp1, oper = A.TimesOp, right = exp2, pos = exp1left})           
       | exp DIVIDE exp                                               (A.OpExp {left = exp1, oper = A.DivideOp, right = exp2, pos = exp1left})          
       (* Comparison *)
       | exp EQ exp                                                   (A.OpExp {left = exp1, oper = A.EqOp, right = exp2, pos = exp1left})         
       | exp NEQ exp                                                  (A.OpExp {left = exp1, oper = A.NeqOp, right = exp2, pos = exp1left})        
       | exp LT exp                                                   (A.OpExp {left = exp1, oper = A.LtOp, right = exp2, pos = exp1left})       
       | exp LE exp                                                   (A.OpExp {left = exp1, oper = A.LeOp, right = exp2, pos = exp1left})              
       | exp GT exp                                                   (A.OpExp {left = exp1, oper = A.GtOp, right = exp2, pos = exp1left})              
       | exp GE exp                                                   (A.OpExp {left = exp1, oper = A.GeOp, right = exp2, pos = exp1left})    
       (* Booleans *)
       | exp AND exp                                                  (A.IfExp({test = exp1, then' = exp2, else' = SOME(A.IntExp(0)), pos = exp1left}))  
       | exp OR exp                                                   (A.IfExp({test = exp1, then' = A.IntExp(1), else' = SOME(exp2), pos = exp1left}))           
       | INT                                                          (A.IntExp INT)

(* Build arrays and records in common *)
arrayRecordBuilder: 
                     (* Arrays *)
                    ID LBRACK exp RBRACK OF exp	                     (A.ArrayExp({typ = Symbol.symbol(ID), size = exp1, init = exp2, pos = IDleft}))
                     (* Records *)
                  | ID LBRACE record_param RBRACE                     (A.RecordExp({fields = record_param, typ = Symbol.symbol(ID), pos = IDleft}))
                  | ID LBRACE RBRACE                                  (A.RecordExp({fields = [], typ = Symbol.symbol(ID), pos = IDleft}))

(* record initializing parameters*)
record_param : ID EQ exp				                     ([(Symbol.symbol(ID), exp, IDleft)])
       | ID EQ exp COMMA record_param		                     ((Symbol.symbol(ID), exp, IDleft) :: record_param)

(* sequential expressions *)
exp_seq : exp                                                         ([exp, expleft])
        | exp_seq SEMICOLON exp                                        (exp_seq @ [(exp, expleft)])

(* access *)
lvalue: ID                                                            (A.SimpleVar(Symbol.symbol(ID), IDleft))
       | lvalue_not_id                                                (lvalue_not_id)  

(* workaround for shift-reduce conflict via ID vs. ID LRACK*)
lvalue_not_id: lvalue DOT ID                                          (A.FieldVar(lvalue, Symbol.symbol(ID), lvalueleft))
              | lvalue_not_id LBRACK exp RBRACK                       (A.SubscriptVar(lvalue_not_id, exp, lvalue_not_idleft))
              | ID LBRACK exp RBRACK                                  (A.SubscriptVar(A.SimpleVar(Symbol.symbol(ID), IDleft), exp, IDleft))

(* declarations *)
dec : funlist                                                         (A.FunctionDec(funlist))
       | tylist                                                       (A.TypeDec(tylist))
       | vardec                                                       (vardec)

declist : dec                                                         ([dec])
        | declist dec                                                 (declist @ [dec])

(* types *)
ty : ID                                                               (A.NameTy(Symbol.symbol(ID), IDleft))
   | LBRACE tyfields RBRACE                                           (A.RecordTy(tyfields))
   | ARRAY OF ID                                                      (A.ArrayTy(Symbol.symbol(ID), ARRAYleft))

tydec : TYPE ID EQ ty                                                 (A.TypeDec({name = Symbol.symbol(ID), ty = ty, pos = TYPEleft})) (* kinda sus жде *)

tylist : tydec                                                        ([tydec])
       | tylist tydec                                                 (tylist @ [tydec])

tyfields :                                                            ([])
         | ID COLON ID                                                ({name = Symbol.symbol(ID1), escape = ref true, typ = Symbol.symbol(ID2), pos = ID1left} : A.field)
         | ID COLON ID COMMA tyfields                                 (({name = Symbol.symbol(ID1), escape = ref true, typ = Symbol.symbol(ID2), pos = ID1left} : A.field) :: tyfields)

(* variables *)
vardec : VAR ID ASSIGN exp                                            (A.VarDec({name = Symbol.symbol(ID), escape = ref true, typ = NONE, init = exp, pos = VARleft}))
       | VAR ID COLON ID ASSIGN exp                                   (A.VarDec({name = Symbol.symbol(ID1), escape = ref true, typ = SOME((Symbol.symbol(ID2), ID2left)), init = exp, pos = VARleft}))

(* functions *)
fundec : FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp           ({name = Symbol.symbol(ID1), params = tyfields, result = SOME((Symbol.symbol(ID2), ID2left)), body = exp, pos = FUNleft}: A.fundec) 
       | FUNCTION ID LPAREN tyfields RPAREN EQ exp                    ({name = Symbol.symbol(ID1), params = tyfields, result = NONE, body = exp, pos = FUNleft}: A.fundec) 
       (* | FUNCTION ID LPAREN RPAREN COLON ID EQ exp                    ({name = Symbol.symbol(ID), params = [], ret = Symbol.symbol(ID), body = exp, pos = FUNleft}) 
       | FUNCTION ID LPAREN RPAREN EQ exp                             () *)

funlist : fundec                                                      ([fundec])
        | funlist fundec                                              (funlist @ [fundec])